# 关于消息队列的思路

## zeromq的模式
其实正常来说的话用一个单向的就够用了,但是按照我的风格肯定会来一个返回值之类的东西,所以肯定是用rep和req这种模式了,然后就是这个作为服务端是生产者和消费者都是作为客户端连接到这个服务端的.

## 逻辑的设计
这个东西单独一个线程就可以了,然后就是开始的话可以很简单的监听那两个端口,然后获取发送的消息,中间用一个队列来缓冲发送的数据,然后生产者发送这个数据之后接收是否正确添加到队列里,队列设置一个最大长度,然后如果超过这个长度之后就会添加失败,然后给生产者返回一个添加失败,卡住生产者,让他停一会,过一会再发这个数据,然后消费者那边如果把队列弄成0的话弹出的时候也会出错,然后给消费者谈一个获取失败,然后让消费者也停一会,整体逻辑就是这样.

## 复杂一点的设计
把监听的两个端口放在两个线程里,然后作为多线程处理,这样可以保证两部分可以同时使用,但是其实我感觉是没必要的,因为完全可以绑定一个端口,然后从端口层就让他们异步执行,这样可以保证线程安全.

## InsideCode的设计
里面一个dict保存多分支需要调用的函数,然后再不要准备一个队列
这个设计感觉有点多余,应该把InsideCode这一部分去掉,然后换成一个高阶函数,然后这个函数里面返回一个dict,dict里面包含着几个不涉及外部变量的函数,这一部分要做的事应该是确定每一个输入的状态应该做什么,然后返回的是应该做什么
设计的时候可以按照函数式的设计风格,然后把这个作为纯函数来解决,然后返回至一个存在于消息队列类里面的函数,然后通过一个返回值来确定多分支以及输入什么数据.
这一层的设计应该是让每一个不同的业务需求都用这么一个高阶函数来处理成统一的格式的.java里面是传递一个类,这里一个高阶函数的dict就够了

## 关于模式
这个InsideCode和外部作为转换的.这里说明一下消息队列支持的模式,然后每一个InsideCode单独设计一套处理方式来转换成这里需要的接口.

### 做一些简单的思考
这里应该是要处理的就是收到生产者的消息之后应该做什么,还有一个就是收到消费者的消息之后应该做什么.

注意一点就是消息队列是通用的,但是InsideCode是不同的,然后对于不同的需求的时候消息队列并不知道他应该做什么,所以应该把这一部分封装成一个单独的函数,然后消息队列把消息传入这个函数里面,然后处理成结果值,然后消息队列就可以按照这个处理之后的结果做需要的事了.

InsideCode的目的就是针对不同的应用场景处理做不同的处理.

当消息队列收到生产者的消息的时候,把这个消息转发给这个InsideCode,然后InsideCode处理这个消息,返回一个tuple,第一个是这个的模式数值,后面是数据.

每一个模式都是对应着生产者产生消息的时候

结构应该改一些,因为有些时候这个消息队列里面存的是多种类型的数据,就像是ajax和Parser推送的数据一样,所以队列应该是一个dict对应的queue,然后该从哪个dict发送数据都应该通过InsideCode中的那个返回值的设定来获取,然后发送到哪个,所以这个设定要设计的更复杂一点.



|数值|模式|备注|
|---|---|---|
|0|终止|这个作为终止条件|
|1|入队|这个分给生产者|
|2|生产返回值|这个是给生产者的返回的|
|3|消费者获取值|这个分给消费者,用来处理消费者发送的数据的|
|4|||